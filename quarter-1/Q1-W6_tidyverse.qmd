---
title: "The Tidyverse"
subtitle: "Ecosystem, read-in/-out, data manipulation"
date: "2/10/2026" # M/D/Y
format:
  revealjs:
    theme: [default, ../theme/d2mr-theme.scss]
    include-in-header:
        # Opt into some
      text: |
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"/>
        <script type="text/javascript" src="../theme/bubbles.js"></script>
    slide-number: c/t
    width: 1600
    height: 900
    margin: .1
    scrollable: true
    incremental: false
    transition: slide
    background-transition: fade
    highlight-style: ../theme/d2mr-code-theme.theme
    code-line-numbers: true
    code-copy: true
    footer: "D2M-R Q1 | Week 6" #  quarter, week, and class
    logo: ""
    chalkboard: true
    multiplex: false
editor: source
execute:
  echo: true
  eval: false
  warning: false
  message: false
---


## Lecture Planning

7. Welcome to the Tidyverse!
    1. Introduction to the Tidyverse & tidy data
        1. Overview of the tidy ecosystem
        2. Tidy data principles
        3. Core packages in the Tidyverse and general functions
        4. Terminology
    2. Importing and exporting with readr
        1. Overview 
            1. Tabular data - what counts?
                1. File types
                2. R objects, including tibbles
            2. Reading, writing, rereading (intermediate datasets)
        2. Reading data with read_* functions
        3. Writing data with write_* functions
        4. Other packages
            1. readxl for Excel files
            2. haven for SPSS, SAS, and Stata files
            3. googlesheets4 for Google Sheets
            4. jsonlite for JSON files
            5. DBI and dbplyr for databases
        5. Handling common import/export issues
    3. Data manipulation with dplyr
        1. Introduction to dplyr
            1. the points of pipelines (highly readable, but verbose)
            2. The pipe operator (%>%) and magrittr
            3. Chaining operations with pipes
        2. Selecting data
            1. select, rename
            2. filter
            3. arrange
        3. Manipulating data
            1. mutate
            2. summarize
            3. group_by
            4. distinct
            5. count
        6. dplyr practice
    4. Data tidying with tidyr
        1. What counts as "tidying" data? 
            1. Remember what "tidy" means in the tidyverse
            2. Tidying is reshaping and systematically cleaning data 
        2. Reshape data
            1. pivot_longer
            2. pivot_wider
            3. cast, melt, gather, spread, etc.
        3. Combine and split cells
            1. unite
            2. separate functions
        4. Expand tables
            1. expand
            2. complete
        5. Handle missing values
            1. drop_na
            2. fill
            3. replace_na
        6. Advanced: Nested data
            1. What is nested data and why might you use it?
            2. We're not going to cover this in D2MR, but tidyr has functions for creating, 
            reshaping, and transforming nested data

# Tidy Data

## What Makes Data "Tidy"? 



::: {.r-stack}

![](../images/tidyverse/tidy-data-def-frag1.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag2.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag3.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag4.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag5-FULL.jpg){.fragment height=700}
:::

<aside>Illustrations from the [Openscapes](https://www.openscapes.org/) blog [Tidy Data for reproducibility, efficiency, and collaboration](https://www.openscapes.org/blog/2020/10/12/tidy-data/) by Julia Lowndes and Allison Horst</aside>

---

![](../images/tidyverse/tolstoy.png){.absolute top="0" right="0" height="200"}

![](../images/tidyverse/tidy-data-quote-frag1.jpg){.fragment height="300"}


![](../images/tidyverse/tidy-data-quote-frag2.jpg){.fragment height="300"}

---

::: columns

::: {.column}

![](../images/tidyverse/tidy-data-workshop-frag1.jpg){.fragment height="800"}

:::
::: {.column}

![](../images/tidyverse/tidy-data-workshop-frag2.jpg){.fragment height="800"}
:::
:::


## Messy vs. Tidy: Example {data-background-image="../images/mms.jpg" data-background-opacity=0.1}

::::: {.container-fluid style="margin-top: -150px;"}
:::: {.row style="margin-bottom: 50px;"}
::: col-6

:::
::: col-6
::: {.callout-important style="font-size: 1.2em;"}

## These tables hold exactly the same data!

What are the differences? What are the advantages of each?

:::
:::
::::




```{r}
#| message: false
#| warning: false
#| eval: true
#| echo: false
library(tidyverse)

mmdata <- read_tsv("../materials/MM.tsv")

mmdata.messy <- mmdata |>
    ## Add a column "Bag" that adds a numeric ID (starting at 1) for each row (ie each bag of M&Ms) 
    mutate(Bag = row_number()) |> 
    select(Bag, everything())

mmdata.tidy <- mmdata.messy |> 
    ## Make the data long so that there is one column for Color and one column for Number of that color
    pivot_longer(cols = c("Red", "Green", "Blue", "Brown", "Yellow", "Orange"),
                 names_to = "Color",
                 values_to = "Number") |> 
    select(Bag, Weight, Color, Number)
    
```

:::: row

::: col-7

```{r}
#| echo: true
#| eval: true

mmdata.messy
```

:::
::: col-5

```{r}
#| echo: true
#| eval: true
mmdata.tidy
```
:::
::::
:::::

::: bubble-chain
  <p class="bubble-left fragment">That messy data looks pretty clean to me...</p>
  <p class="bubble-right fragment">It *is* clean! It's just not **tidy**.</p>
:::


## "Messy" Data Clarification

::: {.callout-important}
**"Messy" data:** any alternative, conventional way of organizing information

**messy ≠ bad** (except in the tidyverse context)
:::

::: {.incremental}
- Data wrangling starts with reading your data, then prepping it for visualization & analysis
- To use tidyverse packages, this prepping includes tidying messy data
- This can be shockingly complicated and time-consuming!
:::

<div class="bubble-chain">
  <p class="bubble-left">Left bubble</p>
  <p class="bubble-right">Another from the right</p>
  <p class="bubble-right">Another really really really really really really really really really really really really really really really really really long one from the right</p>
  <p class="bubble-right">Short right</p>
  <p class="bubble-left">One last one from the left</p>
  <!-- ...mix as desired -->
</div>


# Terminology Detour

## Messy, Clean, Tidy

::: {.callout-note}
**Important Distinctions**
:::

::: {.incremental}
- **Messy** can either mean "not clean" or "not tidy"
- We **never** want data that aren't cleaned. That's bad.
- We **often** want data that are tidy. Good for tidyverse stuff.
- We **sometimes** also want data that aren't tidy.
- Could we call this "untidy"? Yes, that would make more sense.
- But for some reason people just use "messy" for both. Sorry.
:::

## Data Preparation Terms

| Process | Start State | Goal | End State | Examples |
|:-------:|:-----------:|:----:|:---------:|:---------|
| **Data Cleaning** Error correction | Raw data | Accuracy, consistency, legibility | Clean data, not yet specialized | Removing duplicate data<br>Correcting syntax errors<br>Fixing typos<br>Handling missing values<br>Change data types |
| **Data Wrangling** Data preparation | Clean data | Usability for medium-scope purpose | Interpretable and specialized data, not yet analyzable | Preparing for narrow use cases<br>Grouping and summarizing<br>Transforming variables or values |
| **Data Transformation** Data restructuring | Interpretable data | Usability for narrow-scope tasks | Analyzable and visualizable data | Reshaping long ↔ wide<br>Generating new data-based variables<br>Merging datasets<br>Eliminating unnecessary data |

## Terminology Confusion {.smaller}

::: {.fragment .highlight-red}
"You put cleaning/wrangling tasks in the opposite wrangling/cleaning mini-projects!"
:::

::: {.fragment .highlight-blue}  
"Those are the same thing."
:::

::: {.fragment .highlight-green}
"That's not what I learned."
:::

::: {.fragment}
**OK FINE. Yes. You're all correct.**  
**You're also all incorrect.**  
**Honestly it doesn't really matter.**  
**Just mess with your data until they are usable. Call it what you want as long as it works.**
:::

# TidyVerse Packages

## Core Tidyverse Packages

:::: {.columns}

::: {.column width="20%"}
**[tibble]{.pkg}**  
reimagine the dataframe!
:::

::: {.column width="20%"}
**[readr]{.pkg}**  
easily import and export tabular data
:::

::: {.column width="20%"}
**[dplyr]{.pkg}**  
a grammar of data manipulation
:::

::: {.column width="20%"}
**[tidyr]{.pkg}**  
tidy your messy data
:::

::: {.column width="20%"}
**[ggplot2]{.pkg}**  
a grammar of graphics
:::

::::

:::: {.columns .fragment}

::: {.column width="25%"}
**[purrr]{.pkg}**  
enhancements for R's functional programming
:::

::: {.column width="25%"}
**[stringr]{.pkg}**  
simplify working with strings
:::

::: {.column width="25%"}
**[forcats]{.pkg}**  
simplify working with factors
:::

::: {.column width="25%"}
:::

::::

## Core Tidyverse Packages: Week 3 Focus

:::: {.columns}

::: {.column width="20%"}
**[tibble]{.pkg}** ✅  
reimagine the dataframe!
:::

::: {.column width="20%"}
**[readr]{.pkg}** ✅  
easily import and export tabular data
:::

::: {.column width="20%"}
**[dplyr]{.pkg}** ✅  
a grammar of data manipulation
:::

::: {.column width="20%"}
**[tidyr]{.pkg}**  
tidy your messy data
:::

::: {.column width="20%"}
**[ggplot2]{.pkg}**  
a grammar of graphics
:::

::::

# readr

## Tibbles

::: {.incremental}
- Like base R's [data.frame]{.func} structure but **better**
- Tibbles are *also* data.frames
- Tidyverse package(s) work with tibbles, not base data.frames
:::

## readr: Import Tibbles

**Figure out which import function you need for your data:**

::: {.incremental}
- Field separators?
- Non-tabular data?
- Multiple sheets?
- Check that your data file is in a sensible directory and note the path to your file
:::

::: {.callout-tip}
**File Organization Best Practices**
- ALL data in your repo
- Raw, protected data in a localonly dir
- Wrangled or sourced data in git-managed directory
:::

## read_* Functions

```r
# Common readr functions
read_csv()    # Comma separated values
read_tsv()    # Tab separated values
read_delim()  # Any delimiter
read_fwf()    # Fixed width files
read_table()  # Whitespace separated
```

::: {.fragment}
**Note:** `read_csv` vs `read_csv2`
- Most English-speaking countries and countries in Asia use the period as decimal mark (csv)
- Most non-English European countries use a comma instead (csv2)
:::

## BONUS: readxl & googlesheets4

::: {.callout-note}
**Complementary packages to readr**
:::

::: {.incremental}
- Mimic readr's [read_*]{.func} functions
- *Not* tidyverse packages
- Install and load them separately
:::

```r
# readxl for Excel files
library(readxl)
read_excel("data.xlsx")

# googlesheets4 for Google Sheets
library(googlesheets4)
read_sheet("spreadsheet_url")
```

## Importing with readr

```r
# Default behavior - guesses all data types
read_*(file.csv, col_types = NULL)

# Specify columns with cols()
read_*(file.csv, col_types = cols(
  my_factor = col_factor(),
  your_string = col_character()
))

# String shortcut - needs character for each col in order
read_*(file.csv, col_types = "fc")
# Use "?" for columns to guess
```

::: {.callout-tip}
The `adult-data.csv` dataset is in the repo for you to explore and/or use for mini-projects.
:::

## EXPORTING with readr

**Write intermediate datasets after:**

::: {.incremental}
- De-identifying data
- Complex wrangling
- Dropping unneeded data
- Managing empty data
:::

```r
# readr read_*() functions have matching write_*()
write_delim()
write_csv()
write_csv2()
write_excel_csv()
write_excel_csv2()
write_tsv()
```

## Workflow Example

```r
# Start with messy data
messy_df <- read_xlsx("localpath/messy.xlsx", 
                     sheet="my sheet")

# Process in R: tidy, clean, transform...

# Export clean version
clean_df <- # ... your cleaning steps
write_csv(clean_df, "localpath/clean.csv")

# Later, read the clean version
clean_df <- read_csv("localpath/clean.csv")
```

## Practice: Read & Write

::: {.callout-important}
**In-class Exercise**
:::

1. Pull the most recent commit of the d2mr-assessment repo
2. Find the Excel spreadsheet: `in-class-materials/data/MM data.xlsx`
3. Load the [readxl]{.pkg} library
4. Use the [read_excel()]{.func} function to assign the data to a tibble called `mmdata`
5. Examine your data in the console to see if it looks correct

::: {.fragment}
**Oh no!** Thank goodness you are smarter than a computer.
:::

## Troubleshooting

::: {.callout-warning}
**Common Issues**
- "That folder doesn't exist!" (and/or) "It doesn't read/write/both where I want it to."
- Relative paths can be handled differently by [read_*]{.func} and [write_*]{.func}
:::

**Your Task:**
- Open `MM data.xlsx` in Excel and examine it with your human eyeballs
- What about this file creates problems when you read-in?
- How would you fix the issue in Excel? (just think; don't do it!)
- Review the `?read_excel` documentation
- What arguments can you pass to fix the issue on read-in?

# magrittr: THE PIPE %>%

## The Pipe Operator

::: {.callout-note}
**magrittr**: dependency tidyverse package with one purpose – **the pipe operator: %>%**
:::

The **%>%** allows you to:

::: {.incremental}
- create some data %>%
  - change it with function X %>%
  - change it with function Y %>%
  - as much as you like
:::

::: {.fragment}
**Human-readable alternative to multiple embedded functions:**
`as much as you like(change it with function Y(change it with function X(create some data)))`
:::

## Keyboard Shortcut

::: {.fragment .highlight-red}
"That's annoying. It's also annoying to type %>% all the time."
:::

::: {.fragment}
**Fair! Fortunately, RStudio has a built-in shortcut:**

**shift + cmd/ctrl + m**
:::

## Pipe Example

```r
# Assign everything to mmdata.long
# Using the mmdata tbl...
mmdata.long <- mmdata %>%
  # ...select three columns...
  select(Red, Green, Blue) %>%
  # ...then make that 3 col tbl long...
  pivot_longer(cols = c("Red", "Green","Blue"),
               names_to = "Color",
               values_to = "Number") %>%
  # ...then sort that tbl by new Number column...
  arrange(Number)
# Pipeline is over, so everything assigned to mmdata.long
```

## Alternative Pipe: |>

::: {.fragment}
"I thought this was the pipe: |"
:::

::: {.fragment}
Yeah…it is. This is another one. The OR operator pipe `|` looks like a pipe. The tidyverse pipe `%>%` acts like a pipe.
:::

# dplyr

## dplyr: Tidy Transformation

Use the magrittr **%>%** pipe to make data flow smoothly through these core dplyr functions:

:::: {.columns}

::: {.column width="50%"}
**[filter()]{.func}** - subset/sort rows

**[select()]{.func}** - subset/sort columns

**[mutate()]{.func}** - create new column
:::

::: {.column width="50%"}
**[group_by()]{.func}** & **[summarize()]{.func}** - compute summary values

**[arrange()]{.func}** - perform operations on subgroups of data
:::

::::

## filter(): Create a Subset

```r
filter(tbl, cond1, cond2, ...)
```

::: {.incremental}
- Evaluates on **observations** (rows)
- **Conditions** are logical evaluations of **values**
  - specified by column
  - logical operators: `>`, `>=`, `<`, `<=`, `!=`, `==`
- **Returns a tbl** made up of all rows that meet all conditions
:::

**Examples:**
```r
# Condition examples
transport == "bicycle"
has.handlebars(transport) | transport == "boat"
(has.handlebars(transport) & n.wheels(transport) < 3) | 
  (requires.gas(transport) & n.wheels(transport) > 3)
```

## filter(): Under the Hood

```r
# Basically 2 embedded 'for' loops
# FOR each row in tbl
#   FOR each conditional argument
#     Evaluate logic
#     IF true, return tbl (continue loop to next arg.)
#     ELSE (if false), remove row, return tbl (continue loop)
#   when no conditional arg. remain, move to next row
# When no rows remain, return tbl and end loop
```

::: {.fragment}
"Can't I just know how to use it without this explanation?"
:::

::: {.fragment}
Sure! *But* there's going to be an exercise and mini-project posted next class directly related to this kind of thing, so you may want to keep it in mind.
:::

## arrange(): Sort Your Rows

```r
arrange(tbl, col1, col2, ...)
```

::: {.incremental}
- Sort rows
- If 2+ variables, sorts in order given
- Defaults to ascending order
- Use [desc()]{.func} or `-` for descending order
:::

:::: {.columns}

::: {.column width="50%"}
```r
# Sort trial order within subject
arrange(data, subject, trial)
```
```
> subject  trial
> A        1
> A        2  
> B        1
> B        2
```
:::

::: {.column width="50%"}
```r
# Reverse trial order
arrange(data, subject, desc(trial))
arrange(data, subject, -trial)
```
```
> subject  trial
> A        2
> A        1
> B        2
> B        1
```
:::

::::

## select(): Subset, Sort, & Rename Columns

```r
select(tbl, col1, col2, ...)
```

**Basic Examples:**
```r
# From tibble `data` with columns: colA, colB, colC, colD
# Return a tibble with only colA and colB
select(data, colA, colB)
select(data, -c(colC, colD))

# Rename/reorder while selecting
select(data, colC, column_A = colA, colB)

# Select ranges
select(data, colA:colC)    # inclusive range between named columns
select(data, 1:3)          # inclusive range based on column number
select(data, -ends_with("D"))  # use "tidy-select" functions
```

## select(): Advanced Features

::: {.incremental}
- Operates on **variables** (columns)
- Returns tibble that **includes:**
  - argument columns
  - in arg order
  - optionally renamed
- Use hyphen to **exclude** columns
  - Includes everything else
:::

**Related function:** [rename()]{.func}
```r
# Change column names with similar syntax
# but don't change tibble structure
rename(column_B = colB)  # new columns: colA, column_B, colC, colD
```

## mutate(): Create New Variable

```r
mutate(tbl, newvar1 = ...)
```

**Examples:**
```r
# All obs. in new column 'hello' have the same value
mutate(data, hello = "hey there!")

# Obs. in new column are computed by row
mutate(data, col1_plus_col2 = col1 + col2)
mutate(data, round_col1_div_col2 = round(col1/col2, 2))

# Multiple operations in sequence
mutate(data,
  sum_cols = col1 + col2,
  prop_col1 = round(col1/sum_cols, 2))
  
# Change values in an existing column conditionally
mutate(data, colA = ifelse(colA == 0, NA, colA))
```

## group_by() & summarize(): Compute Summary Values

```r
group_by(tbl, col1, col2, ...)
summarize(tbl, newcol = fun(col), ...)
```

:::: {.columns}

::: {.column width="50%"}
**Without Grouping:**
```r
# Average all values in score column
summarize(data, mean_score = mean(score))
```
```
> mean_score
> 20
```
:::

::: {.column width="50%"}
**With Grouping:**
```r
# Average score for each subject
group_by(data, subject) %>%
  summarize(sub_mean_score = mean(score),
           sub_first_score = first(score))
```
```
> subject  sub_mean_score  sub_first_score
> A        18              17
> B        22              20
```
:::

::::

## Advanced Grouping

```r
# Grouping by multiple columns creates summary for each 
# unique combination of values
group_by(data, subject, condition) %>%
  summarize(sc_mean_score = mean(score))
```

```
> subject  condition  sub_mean_score
> A        1          17
> A        2          19
> B        1          24
> B        2          20
```

::: {.callout-note}
- **[summarize()]{.func}** computes across obs. in a variable
- Summarizing without grouping computes across all data
- **[group_by()]{.func}** breaks observations into subsets
- Returns tbl with *only* new summary columns and any grouping columns

**FYI:** `summarize()` == `summarise()`
:::

# Combining Data (Preview)

## Just a Preview...

The binding/merging/joining functions in the tidyverse are part of [dplyr]{.pkg}, so I'm adding reference slides here.

They make more sense to talk about together with the [tidyr]{.pkg} functions next class, so we'll skip these for now and come back to them.

## Bind Rows

**Append *rows* of one dataframe after the last row of another**

:::: {.columns}

::: {.column width="50%"}
**base::[rbind()]{.func}**
- dataframes must have exactly the same columns in the same order
:::

::: {.column width="50%"}
**dplyr::[bind_rows()]{.func}**
- dataframes can have different column structures, missing values will be treated as *NA*
:::

::::

::: {.callout-tip}
**What's with the base:: and dplyr:: bits?**

It's a shortcut to specify what package the function comes from. Usually not necessary in your actual code, but it can come in handy when: 1) you don't have that package loaded and you just need that single specific function or 2) you have multiple packages loaded that define that function and you want to specify which of them to use.
:::

## Bind Columns

**Append *columns* of one dataframe after the last column of another**

:::: {.columns}

::: {.column width="50%"}
**base::[cbind()]{.func}**
- dataframes must have the same number of rows
:::

::: {.column width="50%"}
**dplyr::[bind_cols()]{.func}**
- dataframes must have the same number of rows
:::

::::

::: {.fragment}
"If they work the same way, which should I use?"
:::

::: {.fragment}
**Neither! Use joins instead.**
:::

## Merge Data with *_join() Functions

:::: {.columns}

::: {.column width="50%"}
**[left_join()]{.func}** - includes all the rows of x and only the rows of y that have matches in x

**[right_join()]{.func}** - includes all the rows of y and only the rows of x that have matches in y
:::

::: {.column width="50%"}
**[inner_join()]{.func}** - includes only rows present in both x and y

**[full_join()]{.func}** - includes all rows present in either x or y, matched where possible
:::

::::

::: {.callout-tip}
See r4ds [Chapter 19: Joins](https://r4ds.hadley.nz/joins.html) for more explanation
:::

## *_join() Syntax

```r
*_join(left.tbl, right.tbl, by = ...)
# replace * with left, right, inner, or full
```

**Examples:**
```r
# These are all identical
left_join(band_members, band_instruments)

left_join(band_members, band_instruments, 
         by = join_by(name))

left_join(band_members, band_instruments, 
         by = "name")

# Specify to match columns with different names:
by = join_by(name == artist)

# Specify multiple columns to match:
join_by(a, c == d)
```

# Practice: dplyr

## 💻 Try It Out

**Using the mmdata tibble you created earlier, experiment with:**

::: {.incremental}
- **[filter()]{.func}** - Create subsets based on conditions
- **[select()]{.func}** - Choose specific columns
- **[mutate()]{.func}** - Create new variables
- **[arrange()]{.func}** - Sort your data
- **[group_by()]{.func}** & **[summarize()]{.func}** - Calculate group statistics
:::

# Exercises

## 💻 W3C2: Read/Write Practice (1 of 2)

**In the first code chunk of a new notebook (R/quarto):**

::: {.incremental}
- Use readr functions to read in a simple tabular dataset (.csv/.tsv) using a relative path and assign to a new object
- Use tidyverse functions to transform the data in some way (can be very simple as long as it creates recognizable changes)
- Use readr functions to write your transformed data to a .csv file in the same location as your original data file (give it a unique file name)
- Examine the assigned objects and written files; use one of the objects in a second code chunk
- Make necessary changes if it does not work as expected
:::

**Replicate** the script above in a new .R script in the same directory as your notebook

**In a new chunk,** *source* the .R script, again examine objects/files and make changes so things work as expected

::: {.callout-note}
**Assessed:** 9, 10, 22; **Unassessed:** 2, 4, 10
:::

## 💻 W3C2: Read/Write Practice (2 of 2)

**Find or create a variety of datasets to repeat the process:**

::: {.incremental}
- **Different file types:** .csv, google sheets, .xlsx, .sav, etc.
- **Different "extra" stuff:** multiple tabs, rich formatting, non-data text, header(s), etc.
- **Different combinations of file locations:** notebook and script in root folder, one in root folder and one in a subdirectory, both in two different subdirectories, writing/reading files in a lower-level subdirectory, writing/reading files in a higher-level subdirectory, etc.
:::

**Pay attention to:**
- Which packages are necessary to run which functions
- Which functions include which arguments (and the default argument values)
- Differences in relative paths depending on function and file locations

## 💻 W3C2: Data Cleaning

::: {.callout-important}
**Important:** These exercises include functions from tidyverse packages we will cover next class. Look ahead with the resources for next class or do what you can now and finish it next week.
:::

**Find three data cleaning exercises (1 walkthrough example; 2 structured assignments) in the d2mr-assessment repo.** Complete the mini-projects directly in the existing .qmd like a digital workbook.

::: {.incremental}
- **Data cleaning walkthrough:** Clean the iris Dataset (example, not a mini-project to complete/submit)
- **Level 1 Data Cleaning:** Clean the mtcars Dataset - Work with a simple dataset, focus on basic data cleaning tasks
- **Level 2 Data Cleaning:** Clean the midwest Dataset - Work with a more complex dataset, perform more involved cleaning tasks
:::

::: {.callout-note}
**Assessed:** 5, 6, 8, 9, 10, 11, 12; **Unassessed:** 1, 2, 9, 12, 13
:::

## 💻 W3C2: Group "Uncleaning"

**Work together with a classmate to each "unclean" a dataset for the other(s) to clean.** This will work best in pairs so that you can swap datasets but you can adjust things to do in a small group if you prefer.

::: {.incremental}
1. Each partner chooses a publicly available dataset (recommend the built-in ones)
2. In a script or notebook, transform your df to make it messy and save to a .csv
3. Swap your new messy data files
4. In a (different) script or notebook, clean your partner's messy data
5. Discuss the process with your partner/group
:::

**Associated mini-project:** `d2mr-assessment/01_data-cleaning/03_group-unclean`

::: {.callout-note}
**Assessed:** 5, 6, 8, 9, 10, 11, 12; **Unassessed:** 1, 2, 5, 9, 14, 22
:::

# Resources 🗃️

## Today's Class

**tidyverse.org:** [https://www.tidyverse.org/](https://www.tidyverse.org/)

**readr:**
- [documentation](https://readr.tidyverse.org/) & [cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-import.pdf)
- [r4ds: 7 – Data import](https://r4ds.hadley.nz/data-import)

**tibble:**
- [documentation](https://tibble.tidyverse.org/) & [r4ds: tibbles](https://r4ds.had.co.nz/tibbles.html)

**dplyr:**
- [documentation](https://dplyr.tidyverse.org/) & [cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf)
- [r4ds: 3 – Data transformation](https://r4ds.hadley.nz/data-transform)

## Next Class

**tidyr:**
- [documentation](https://tidyr.tidyverse.org/) & [cheatsheet](https://rstudio.github.io/cheatsheets/html/tidyr.html)
- [tidyverse guide to tidy data](https://tidyr.tidyverse.org/articles/tidy-data.html)
- [r4ds: 5 – Data tidying](https://r4ds.hadley.nz/data-tidy)*

**stringr:**
- [documentation](https://stringr.tidyverse.org/) & [cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf)
- [r4ds: 14 – Strings](https://r4ds.hadley.nz/strings)*
- [r4ds: 15 – Regular expressions](https://r4ds.hadley.nz/regexps)

## More Resources

**forcats:**
- [documentation](https://forcats.tidyverse.org/) & [cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/factors.pdf)
- [r4ds: 16 – Factors](https://r4ds.hadley.nz/factors)*

**purrr** *(advanced, low priority for d2mr)*:
- [documentation](https://purrr.tidyverse.org/) & [cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/purrr.pdf)

**Quick Help:**
```r
?paste
?paste0
?filter
?read_csv
??read_csv  # search for functions
```
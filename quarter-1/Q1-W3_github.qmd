---
title: "Git & GitHub"
subtitle: "version control, github, rstudio integration"
date: "1/20/2026" # M/D/Y
format:
  revealjs:
    theme: [default, ../theme/d2mr-theme.scss]
    include-in-header:
      text: |
        <script type="text/javascript" src="../theme/bubbles.js"></script>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"/>
    slide-number: c/t
    width: 1600
    height: 900
    margin: .1
    margin-bottom: "120px"
    scrollable: true
    incremental: true
    transition: slide
    background-transition: fade
    highlight-style: ../theme/d2mr-code-theme.theme
    code-line-numbers: true
    code-copy: true
    footer: "D2M-R Q1 | Week 3"
    logo: ""
    chalkboard: true
    multiplex: false
editor: source
execute:
    echo: true
    eval: false
    warning: false
    message: false
---

## Lecture planning

Git & GitHub Essentials Chapter

1. Introduction -- the point of version control
2. Git
  1. Overview & workflow musts
  2. Git lingo
    1. Repositories
      1. repository / repo
      1. initialize
      2. clone
      3. branch & checkout
    2. Version control
      1. commit
      3. stage
      4. fetch
      6. pull
      7. push
  3. Merging
      1. diff
      2. merge
      3. merge conflict
      4. rebase
      5. fast-forward (ff)
      6. squash
      7. cherry-pick
      8. stash
    4. Remote repositories
      1. remote
      2. origin
      3. upstream
      4. fork
      5. pull request
    5. (Optional) Using Git in the terminal
3. Repo structure
  1. What does and does not go in a repo?
  2. Top-level essentials
      1. README
      2. .gitignore
  3. The rest of your stuff
  4. Metadata and information
4. GitHub
  1. What is GitHub? How is it different from Git?
  2. GitHub features
    1. Issues
    2. Pull requests
    3. Pages
    4. Copilot
    5. More
      1. Actions
      2. Projects
      3. Codespaces
  4. Interfacing with GitHub (without RStudio)
    1. GitHub website
    2. GitHub Desktop
    3. Other options
      1. VS Code and other IDEs
      2. GitHub CLI
  5. Interfacing with GitHub in RStudio
    1. Connecting RStudio to GitHub
    2. Using GitHub in RStudio
      1. Cloning a repo
      2. Committing changes
      3. Pushing changes
      4. Pulling changes
      5. Creating pull requests
6. Git Pains
  1. Common issues
  2. Helpful resources
  3. The nuclear option

```{=html}
<!-- 
ASSETS NEEDED:
- Git workflow diagram (commit, push, pull)
- xckd/phdcomics/etc
- Side-by-side renders
    - README.md
    - repo structure
- Screenshots
    - GitHub interface screenshots
    - Merge conflict examples
    - .gitignore file examples
-->
```

## Housekeeping {.smaller}

-   **Accountability plans due TODAY**
-   Make sure you have GitHub account created
-   RStudio + Git setup: [happygitwithr.com](https://happygitwithr.com/)
-   Practice from last week: How's your RStudio customization going?

# Why Version Control?

## Final_NDrevisions-finalmarch22_FINALFINAL.docx

![PhD Comics: "FINAL".doc](../images/comics-memes/phd-comics-finaldoc.gif)

## Version Control Basics

<!-- allow column grid to overlap vertically with the title space -->
:::::::: {.container-fluid style="margin-top: -3em;"}
::::::: row
:::::: {.col-5 style="padding-top: 3em;"}

-   **Minimally:**
    -   **What changed?**
        -   additions, deletions, modifications
    -   **When?**
        -   timestamp for each change
    -   **Who changed what**
        -   track author contributions in collaborative work
    -   **Revert changes**
        -   go back to any previous version instantly

::::::
:::::: {.col-7}

![Google Doc version history](../images/screenshots/google-doc-version-history.png)
::::::
:::::::
::::::::


::: notes
"version control" is basically a system for keeping track of changes to files over time. A very simple and user-friendly version control system is what you'll find in the "version history" of edits on a google doc.
:::

## Git Version Control

<!-- allow column grid to overlap vertically with the title space -->
:::::::: {.container-fluid style="margin-top: -3em;"}
::::::: row
:::::: col-7

<!-- nested container for text -->
::::: container-fluid

:::: row
::: {.col-12 style="padding-top: 3em;"}
[Git]{.keyword} is a robust version control system designed for text-based files
:::
::::

<!-- columns --> 
:::: row
::: {.col-3 .tightlist}
-   **All the basics:**
    -   What?
    -   When?
    -   Who?
    -   Revert!
    
:::

::: {.col-9 .tightlist}
-   **Plus:**
    -   **Which change is this?**
        -   unique IDs for every revision
    -   **Why did it change?**
        -   commit messages explain purpose
    -   **Branch and merge**
        -   work on multiple features simultaneously
    -   **Backup**
        -   project ("repository") history lives in multiple places
    -   **Asynchronous collaboration**
        -   identify and resolve conflicting changes
    -   **Integration**
        -   with IDEs (e.g., RStudio) and cloud services (e.g., GitHub)
        
:::
::::

:::::
<!-- end nested container -->
::::::

:::::: col-5
![Git commit history](../images/screenshots/github-commit-history.png){style="height: 1200px"}
::::::
:::::::
::::::::

::: notes
Version control is like having a complete backup of every version of your project, plus a detailed log of what changed and why. It's not just for programmers - anyone who works with files that change over time benefits.
:::

## Git Repositories

A [repository]{.keyword} (or "repo") is a project folder tracked by Git. Everything Git does is centered around repos.

Any folder on your computer can be turned into a Git repository (i.e. "initialized"), but a well-organized repo typically includes a few key components:

-   Project files (e.g., scripts, data, documents)
-   Metadata files (hidden files and directories that Git uses to manage version control)
-   Bespoke files like `README.md`, `.gitignore`, and `.yml` files (more on these later)

Git repos can be local (on your computer) or remote (hosted on a server like GitHub).


## Git ≠ GitHub

::::: {.container-fluid}

:::: row
::: {.col-12 .fragment}
[GitHub]{.keyword} is a web-based platform for hosting public and private Git repositories. It is designed to promote code sharing and collaboration, but very useful for individuals, too.

GitHub and Git are related, but not the same thing.

:::
::::

:::: row
::: {.col-4 .fragment}

### Git
-   **Version control system**
-   Tracks changes in metadata files
-   Your files + metadata files = project [repository]{.keywork} (aka "repo")
-   Repos stored locally on your computer
-   Works offline
-   Free & open source
-   *The* standard for version control
:::

::: col-4

![](../images/branded/octocat.png)
:::

::: {.col-4 .fragment}
### GitHub

-   **Web-based hosting service**
-   Cloud storage for Git repositories
-   All repo contents, full history, additional features
-   User-friendly web interface for Git
-   Collaboration tools
-   Free and paid features
-   *One* of many Git hosting services
:::

::::
:::::

::: notes
Education users (anyone with a .edu address) can access premium features for free.

**Analogy:** Git is like a local photo album, GitHub is like posting photos to Instagram.

Git does the version control work on your computer. GitHub is just one place to store and share your Git repositories online. There are alternatives like GitLab, Bitbucket, etc.
:::

## GitHub Features

::::: {.container-fluid}
:::: row
::: {.col-5 .fragment}

In this class we'll use GitHub to:

-   Maintain all class materials
-   Create and share your own code and projects
-   Practice git and GitHub skills
-   Collaborate on group projects

:::

::: {.col-7 .fragment}

But GitHub offers many more features, including:

-   **Issues** to track tasks, enhancements, and bugs
-   **Pull requests** to propose and discuss changes before integrating them into the main project
-   **GitHub Pages** to host websites directly from a repository
    -   like the class site!
-   **GitHub Copilot** to assist with code generation and suggestions
-   **Actions** to automate workflows
-   **Projects** to organize and prioritize work
-   **Codespaces** to provide cloud-based development environments

:::
::::
:::::

::: notes

Some of these extras you'll be able to play around with during this course, but they won't be explicitly part of the syllabus. Developing familiarity with these features can contribute to the engagement portion of your grade.

:::

# Git Fundamentals

## Git Vocabulary

Not all of these are essential at the start, but you should quickly get comfortable with [the ones highlighted in red]{.critical}.

::::: container-fluid

:::: row

::: {.col-6 .fragment .tightlist}

### Repo-level 

-   **[Repository]{.critical} or [repo]{.critical}** 
    - **a project folder tracked by Git**
-   [init]{.keyword} 
    - initialize a new Git repository
-   **[clone]{.critical}**
    - **create your own personal copy of an existing repository**
-   [fork]{.keyword} 
    - copy a repository keeping a connection to the original
-   [branch]{.keyword} 
    - create your own temporary line of work in a repo
-   [checkout]{.keyword} 
    - switch between branches in a repo

:::

::: {.col-6 .fragment .tightlist}

### File-level

-   **[commit]{.critical}**
    - **save a snapshot of changes with a descriptive message**
-   [fetch]{.keyword}
    - get latest changes from remote repo without merging
-   [merge]{.keyword}
    - combine changes from different branches
-   **[pull]{.critical} **
    - **get latest changes from remote repo (=fetch+merge)**
-   **[push]{.critical}**
    - **send your commits to remote repo**
-   [merge conflict]{.keyword}
    - conflicting changes that need manual resolution

:::
::::

:::: row
::: col-12
::: {.callout-note .fragment}

### More to look for on your own

diff, stash, rebase, tag, cherry-pick, revert, reset, HEAD, remote, origin, upstream

:::
:::
::::

:::::


::: notes
Repo: A directory (i.e., folder) the holds all documents and document edits associated with a project
Init: Initializing a repo, making an existing directory ready to work with git (RStudio will do this for you)
Clone: Copy an existing repository, creating a fully distinct and separate repo that you own and control
Fork: Copy an existing repository, maintaining a connection to the original; you have full control over your fork, but not the original repo
Branch: Create an isolated segment of a repo (that you own), so that you can make many changes before combining it back with the original (for collaboration) 
Checkout: Swap between different branches of a repo

Commit: A snapshot of changes in the repo; documented with an informative note left for posterity called a commit message

Pull: Synchronizing your local repo with latest changes from a remote server (like Github)

Push: Sending your commits (and the changed docs) from your local repo to the remote server

Diff: The process run by git comparing and combining old and new files when you push changes

Merge: The resulting process of a diff, where multiple versions of a file are intelligently combined 

Merge conflict: Error (recognized in the diff) where multiple changes to any single line of text can’t be automatically resolved and require user decisions

:::

## Commits: Snapshots in Time

A [commit]{.keyword} is the metadata associated with a change.

::::: container-fluid
:::: row
::: col-6

``` bash
commit a3d2f1b
Author: Natalie Dowling <ndowling@uchicago.edu>
Date: Mon Jan 20 14:30:15 2026
    
    Add data cleaning script for survey responses
    
    - Remove duplicate entries
    - Standardize column names  
    - Handle missing values in age variable
```

:::
::: col-6

``` bash
commit UNIQUE ID HASH
Author: YOUR NAME <YOUR@EMAIL.ADDRESS>
Date: FULL DATE & TIMESTAMP
    
    ONE LINE SUMMARY OF CHANGE(S)
    
    - OPTIONAL
    - DESCRIPTIVE
    - DETAILS
```
:::
::::
:::::

## Commit Messages: Best Practices

::::: container-fluid
:::: row
::: {.col-6 .fragment}

### Good commit messages:

-   Describe *what* and *why*, not *how*
-   Start with a present tense verb ("Add", "Fix", "Update")
-   First line under 50 characters

::: fragment
```md
Add data cleaning script for survey responses

Move glms out of qmd into a separate script

Start zero-drafting methods
```
:::

:::

::: {.col-6 .fragment}
### Bad commit messages:
-   Vague 
-   Uninformative
-   Cover way too many or unrelated changes

::: fragment
```md
Updates to data

Friday afternoon commit

data cleaning script, move glms, start methods, fix typos, add bibliography
```
:::
:::
::::

:::: row
::: col-12
::: {.callout-warning .fragment}

### A shameful confession


I am a total hypocrite and rarely follow these "good" and "bad" guidelines. The longer I work, the more likely my commit messages devolve into `oops i broke the kid data but the adult glms work now` or `omg i can't anymore here are some broken plots fix this later or don't i don't care` or `i need a drink`. 

These are actual commits from my actual repos. I'm not proud. Present-me is often pretty frustrated with past-me's choices, but I can't pretend that I don't also find it entertaining and humanizing. (You'd think I wouldn't need to humanize myself *to myself*, wouldn't you? You'd be wrong.)

While I encourage you to do as I say, not as I do, what actually matters is that you 1) **commit often** and 2) write **messages that make sense** to anyone who has to read them (including, hopefully, future you).

:::
:::
::::
:::::


<!-- ::: {.callout-warning .fragment .bigger style="position: absolute; width: 70%; left: 0; right: 0; top: 0; margin: 0 auto; z-index:999;"} -->

<!-- ### A shameful confession -->


<!-- I am a total hypocrite and rarely follow these "good" and "bad" guidelines. The longer I work, the more likely my commit messages devolve into `oops i broke the kid data but the adult glms work now` or `omg i can't anymore here are some broken plots fix this later or don't i don't care` or `i need a drink` (These are actual commits from my actual repos. I'm not proud.) -->

<!-- Present-me is often pretty frustrated with past-me's choices, but I can't pretend that I don't also find it entertaining and humanizing. (You'd think I wouldn't need to humanize myself *to myself*, wouldn't you? You'd be wrong.) -->

<!-- While I encourage you to do as I say, not as I do, what actually matters is that you **1) commit often** and 2) write **messages that make sense** to anyone who has to read them (including, hopefully, future you). -->


<!-- ::: -->



::: notes

:::



## The Basic Git(Hub) Workflow

1. **Pull changes** 
    - Every time you sit down to work, before doing anything else
2. **Commit changes**
    - Very frequently!
    - Any time you've made a "nameable" change
    - Use brief, informative commit messages
3. **Push changes**
    - Don't forget to commit first
    - Every time you pause or complete a work session

<!-- TODO: find/create workflow diagram -->

::: notes
This means you should have way more commits than pushes. Each commit is a snapshot of your project at a specific point in time. Pushing sends all your committed changes to GitHub.
:::

## Git in the Command Line / Terminal

Local git repos are managed through the command line (Terminal on Mac, Git Bash on Windows). The process of sitting down to work, pulling from an upstream repo, making a few changes, adding those edited files to the staging area, committing with a brief commit message, and then pushing to upstream at the end of your work session might look something like this:

``` bash
cd repos/d2m-r/slides
git pull origin main
## at this point make changes to files in RStudio or wherever
git add .
git commit -m "Create first draft for GitHub lecture"
git push origin main
```

## Git in RStudio

In D2M-R, you'll interact with Git through RStudio rather than Terminal or Command Prompt. 

You'll mostly use the Git pane, which gives you a pretty user-friendly interface for the same commands you would run in the terminal.

<!-- ![RStudio Git Pane](../images/rstudio-git-pane.png) -->

But you can also use the Terminal tab in RStudio to run git commands directly, exactly as you would in a standalone terminal.

You'll need this for more advanced tasks like resolving merge conflicts, but you can always opt to use it instead of the interface if you prefer.


# Git Project Components

What literally goes in your git repo?

## Repository Structure

A typical Git repository includes:

-   **Project files**
    -   The actual content of your project (e.g., scripts, data, documents), organized in a logical folder structure
-   **Metadata files**
    -   Hidden files and directories (like `.git/`) that Git uses to manage version control
-   **README.md**
    -   A markdown file that provides an overview of the project, instructions for use, and other relevant information
-   **.gitignore**
    -   A text file that specifies which files or directories Git should ignore
-   **Configuration files** (as needed)
    -  Things like `.yml` options, bibliography files, themes, etc.


## Repo Structure: Example 1

My preferred structure for a Quarto manuscript project:

::::: {.container-fluid}
:::: row
::: {.col-6 .tightlist .fragment}

### Project file directories

1. `/localonly`: only present in your local R Project, listed in your .gitignore and never synced to github
2. `/data`: .csv/tabular data files for all raw or intermediate datasets read into in your .qmd, optional `/raw` subfolder for raw data read (only) into unsourced R scripts
3. `/source`: .R scripts to be called in an early chunk of your .qmd, e.g., stylistic preferences, functions, minor data wrangling
4. `/images`: exported figures and any image files to read-in to your R Markdown manuscript
5. `/_extensions`: auto-generated or installed Quarto extensions, like apaquarto

:::

::: {.col-6 .tightlist .fragment}

### Top-level files

1. `README.md`: project overview, repo structure, to-do list, etc.
2. `.gitignore`: starting from the R .gitignore template
3. `project-manuscript.qmd`: the home of your eventual publication 
4. `bibliography.bib`: a plain-text file containing all the BibTeX entries cited in your manuscript
5. `yourCitationStyle.csl`: the script used to format in-text and bibliography citations when knitting

:::
::::
:::::


::: notes

Not everything is needed for every project. For example, extensions like apaquarto will create and store a .csl file within the extension files; you won't see it in your top-level directory.

For the kind of Quarto project we're focusing on in this class, you will always have **exactly 1 .qmd** file, which is the manuscript itself. It lives in the top level directory alongside your readme and gitignore.

:::

## Repo Structure: Example 2

A simple, generic project:

```         
my-research-project/
├── README.md
├── my-project.Rproj  
├── .gitignore
├── data/
│   ├── raw/                # Original data (maybe not in Git)
│   └── processed/          # Cleaned data  
├── scripts/
│   ├── 01_clean.R          # Numbered workflow
│   ├── 02_analyze.R
│   └── functions.R         # Reusable functions
├── outputs/
│   ├── plots/
│   └── tables/
└── docs/
│   └── analysis.qmd        # Main report
├── localonly/              # LISTED IN YOUR .GITIGNORE
    └── protected-data/     # ONLY EXISTS ON YOUR COMPUTER, NOT GITHUB
```

## Hidden files and directories

Repos and R Projects will also include some hidden files and directories

- `.git/` - Git metadata, what makes Git work
- `.Rproj.user/` - RStudio project settings
- `.quarto/` - Quarto project settings

You won't interact with these directories directly, and you won't see them in RStudio or on GitHub.

You may also have other hidden files, for example:

- `.Rproj`
- `.RData`
- `.Rhistory`
- `.DS_Store`  

You won't interact with these either but they won't always be fully hidden in every interface. You can add them to your `.gitignore` file so they don't clutter up your repo.


## README.md

::::: {.container-fluid style="max-width: 40%; margin-left: 0; margin-right: auto;"}

A `README.md` file provides a project overview. It is typically the first thing someone sees when they visit your repository on GitHub.

-   Simple markdown (`.md`) document
-   What you see rendered on a repo's GitHub page
-   Can do lots of things, but should at a minimum describe:
    -   Purpose of the repo
    -   Dataset(s)
    -   Repo structure
    -   Any relevant licensing, restrictions, or citations

:::::

<!-- right-aligned, stacked images -->
::::: {.container-fluid style="position: absolute; width: 60%; right: -100px; top: -100px; bottom: -100px; margin: auto;"}

![](../images/screenshots/readme-md.png){style="width: 100%"}

![](../images/screenshots/readme-html.png){style="width: 100%"}
:::::

## .gitignore: what

::::: container-fluid
:::: row
::: {.col-6 .fragment}

A `.gitignore` file tells Git which files and directories to ignore when comparing differences between versions.

-   Plain text file w/out extension
-   Files & folders that should be excluded from all git processes
-   Matched on strings in file/folder names, including wildcard characters and simplified regex
-   [View documentation](https://git-scm.com/docs/gitignore)

:::

::: {.col-6}

![](../images/screenshots/gitignore.png)

:::
::::
:::::

## .gitignore: why

::: {.alert .alert-danger}

**Not everything belongs online.**

:::

-   [**PRIVACY.**]{style="color: #A4343A;"}
    -   **Do not upload anything with sensitive or identifiable information.**
    -   It is your responsibility to follow your IRB.
-   **Security**
    - passwords, security keys, login tokens
-   **Bloat**
    -   Git is designed for text files
    -   Large files push *very* slowly and can cause RStudio to hang
    -   Some files are regenerated automatically
-   **Conflict**
    -   "behind the scenes" files that actually interact with local, git, or R processes will conflict for baffling reasons (sort of a technological observer effect)



## .gitignore: how

::: {.row .narrowlist}
::: {.col-4 .fragment}

**Optionally start with [a template](https://github.com/github/gitignore/blob/main/R.gitignore)** then:

-   Use informative `# comments`
-   Protect private data in a `localonly/` folder
    -   Dedicated place for anything you need to keep offline that the .gitignore might not explicitly catch
    -   Good place to keep deanonymized datasets instead of trusting yourself to remember to add them to the .gitignore
-   Ignore files/folders 
    - Matching the name: `data/raw/sensitive_data.csv`, `topsecret/`
    -   Using wildcards: `*.pdf`, `no-git_*`

::: 

::: {.col-4 .fragment}

**Ignore large files**

-   Media files: e.g, `*.png`, `*.jpg`, `*.mp4`
    -   tend to be very large, often contain sensitive info
-   Presentation files: e.g., `*.pptx`, `*.key`
    -   not necessary for reproducibility, often large
-   Specialized and raw files: e.g, `*.bdl`, `*.ear`, `*.mgh`
    -   data needs to be tabular eventually anyway

:::

::: {.col-4 .fragment}

**Ignore auto-generated files**

-   System files: e.g., `*.DS_Store`, `*.RData`, `*.Rhistory`
    -   platform-specific, or not text-based
-   Process files: e.g., `*.log`, `*.aux`, `*.out`
    -   should be deleted after success but can stick around if knitting fails
-   Compiled files: e.g., `*.pdf`, `*.docx`, `*.html`
    -   recreated every time you knit

:::
:::

